# README - Documentation for HgBugs, a distributed bug tracker extention for Mercurial
#
# Copyright 2010 Michael Diamond <michael@digitalgemstones.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2 or any later version.
# http://www.gnu.org/licenses/licenses.html
# http://www.gnu.org/licenses/gpl.html

Version 0.5.0 - Feature Complete Beta

Introduction:
	
	Based off and built using Steve Losh's brilliantly simple task manager t
	(http://stevelosh.com/projects/t/) the fundamental principle is 
	'Get things done, not organized', and tries to follow t's motto,
	"the only way to make your bug list prettier is to fix some damn bugs."
	
	That said, HgBugs has many powerful additions to t, without any of the bloat
	and burden of setting up, maintaining, or using a traditional bug tracker.
	
	You can use HgBugs exactly like t, add, rename, resolve, and list work almost
	exactly like t out of the box, with the added benefit that wherever you are in
	a repository, you maintain a single bugs database in the root of the repository.
	
	But you can do more with HgBugs.  You can reopen issues - a feature starkly
	lacking from t.  The edit, details, and comment commands allow you to track
	additional information about the bugs, like stack traces and expected results,
	and whatever other information you'd like.  The details file is a plain text
	file, and can contain any content you desire.
	
	You can also assign bugs to specific individuals - either based on their
	commit names or not - and list lets you filter by owner to see what tasks
	are in your care.
	
	HgBugs is powerful enough to support several different workflow complexities,
	from an individual just tracking tasks in a repository, all the way up to a
	small, distributed team of managers and developers who need to be able to
	report, manage, and assign bugs, tasks, and issues, share details, and
	express their opinions.
	
	However, HgBugs is not intended to be be a replacement for large scale
	bug trackers like Jira, Bugzilla, and the upcoming Bugs Everywhere.  Most
	notably, (at present) HgBugs is just a command line tool.  There is no
	centralized bug list or web access, nor any GUI interface, and many of the
	features in such larger projects are lacking, notably any kind of warning or
	notification when a bug is reassigned, and the ability to categorize bugs and
	to provide resolution reasons, like fixed or duplicate - of course these could
	all be done manually, but there is no such built in functionality.
	
	If you find many of those extra features to be unhelpful bloat when you're
	trying to keep track of your smaller projects, and you don't care to waste
	time organizing, categorizing, and sorting however, HgBugs is the tool to use!

Some Suggested Use Cases:

	A single developer, working on a small project, can turn that into a version
	controlled project with a simple 'hg init', and with HgBugs, he (or she) also
	gets a fully functional bug tracker to boot, no additional setup required!
	
	Working on a website, you could very easily (and I might do this myself 
	soon enough) write a little PHP script which takes bug reports and logs 
	them to HgBugs.  I often find the closer to where my workflow a tool is
	is the easier it is to use, so integrating it right into the website
	makes a lot of sense.
	
	Working on a small project with a few other team members is ideal for HgBugs,
	it's powerful enough to let everyone track what they need to do, and allow
	everyone to contribute what they can to any of the bugs on file.  They can
	search titles for matching bugs, and even grep through the details directory
	to find details matching what they're looking for.
	
	Working on a larger project with lots of team members starts getting questionable,
	as many of the powerful features larger projects provide start to really show
	their worth.  However in my experience serveral large companies I've worked for
	or with have drastically underutilized the power of their bug trackers, to the 
	point where all the complexity and extra metadata is just wasted space and fluff.
	That's not to say that HgBugs is necessarily a good alternative for a large company,
	especially if you deny your employees access to anything they don't need-to-know
	distributed version control, and therefore HgBugs is certainly not for you.
	But it's worth asking yourself if you really benefit from all the extra tools;
	many companies could get by just fine with the features HgBugs provides.

Installing HgBugs:
	
	Like any Mercurial Extention, to install HgBugs edit a Mercurial config file
	and add the following:
	
	[extensions]
	bugs=/path/to/bugs.py
	
	See the Mercurial wiki (http://mercurial.selenic.com/wiki/UsingExtensions)
	for more details.

Config Options:
	    
	Bugs has two configuration settings, both of which are optional, and should
	be put in the [bugs] section of any config file.
	
	user
	    You can specify a user name for bug tracking, or 'hg.user' if you wish
	    to use your commit name.  The bug tracker will work absolutely fine
	    without this setting, but it is recommended if you will be working
	    with multiple people.
	
	dir
	    Allows you to specify (relative to the repo root) where the bugs
	    database should go.  The default is 'REPOROOT/.bugs'
	    
Using HgBugs:
	
	You're encouraged to read the documentation on t (http://stevelosh.com/projects/t/)
	before using HgBugs - much of the functionality and usage philosophy of t is
	carried over here. 
	
	All HgBugs commands take the form 'hg bug command [options/parameters]'.  You
	can see a full list and command signatures by running 'hg help bugs'.
	
	When you're anywhere within a repository with the HgBugs extension enabled
	you can use HgBugs.  To file a new bug, all you have to do is say
	% hg bug add 'This is a new bug'
	And you can confirm it's been added by calling:
	% hg bug list
	Which will show you your new bug, along with an ID to refer to it by.  These
	IDs are actually prefixes of the full bug ID, and will get longer as more bugs
	are added.  If you need a permanent reference to a bug, you can call
	% hg bug id [ID]
	This will return the full ID of the bug.  You'll likely only ever need the first
	six or so characters - a database of 20,000+ bugs only used the first four or five
	in most cases.
	
	To rename a bug, you can call:
	% hg bug rename ID 'NEW NAME HERE'
	And like t's edit command, you can use sed style replacements if you so desire.
	
	When you're finished with a bug, simply call
	% hg bug resolve ID
	and it will be marked resolved and no longer (by default) show up in your bug list.
	Use 'reopen' in the same fashion if you decide to reopen a closed bug.
	
	If you need to record more detail than just a title, edit
	% hg bug edit ID
	will launch your default commit editor with a pre-populated set of sections you can
	fill out.  Nothing is mandatory, and you can create or delete new sections as you'd
	like.  It's suggested however that you leave the comments section at the bottom of the
	file.
	
	To view the details of a bug you call:
	% hg bug details ID
	This provides some basic metadata like date filed and owner, along with the contents
	of the details file, if it exists.  Any sections (denoted by text in square brackets)
	which are empty are not displayed by the details command to simplify the output.
	
	If you want to add a comment to a bug, like feedback or an update on its status,
	% hg bug comment ID 'COMMENT TEXT'
	will append your comment to the details file (this is why you should leave the
	comments section at the bottom of the details file when editing) along with the date
	and, if set, your username (see below)
	
	To manage multi-user projects, you can set a bug username (see the Config Options
	section above for how to do that) to associate with bugs, and say something like
	% hg bug assign ID 'John Cleese'
	If the specified username can't be found in the database, you'll be prompted to 
	confirm that is the name you want to use, with the '-f' flag.  For ease of
	assiging bugs, you can use a prefix of a user's name, and as long as it's not
	ambiguous, HgBugs will assign it to the matching username, and let you know
	who it was ultimately assigned to so you can double check.  Assuming no other
	users named John, calling:
	% hg bug assign ID john
	would have the same effect as the call above.  The special name 'me' will
	assign the bug to your username, and the special name 'Nobody' will mark the bug
	as unassigned.
	
	To see a list of all users, and the number of open bugs assigned to them,
	you can call:
	% hg bug users
	
	Finally, list has some advanced functionality that's worth knowing.  First
	the '-r' flag will list resolved bugs, instead of open bugs.  The -o flag
	takes a username (or a username prefix) and lists bugs owned by the specified
	user.  The -g flag will list bugs which contain the specified text in their
	title.  These flags can be used together for fairly granular browsing of
	your bugs database.
	
FAQ:
	How well does HgBugs scale?
		HgBugs is still well in beta, and it has not been fully tested or benchmarked.
		However test bug lists of more than 20,000 records have been constructed
		and HgBugs has responded excellently, taking less than a second to add
		a record, and even less time to list bugs, filtering by owner or by grep.
		
	I would really like to be able to categorize my bugs, or detail how the bug
	was resolved, why isn't that possible?
		HgBugs is not trying to replace large scale, metadata driven bug trackers,
		and if you find yourself wishing it had these sorts of features, you may
		very well be looking at the wrong product.  However, you could certainly
		add such data to the beginning of the details file, and as long as you don't
		intend to list bugs by this information, it would really work no differently
		than storing it as metadata.
	
	Why doesn't HgBugs commit my changes or add my details files?
		Adding the files to the repositories automatically is likely an upcoming
		feature.  However HgBugs does not commit after bugs are filed or changed
		intentionally.  The hope is that HgBugs acts completely transparently to 
		the underlying repository, and that commits are never solely about bugs
		(unless the user chooses so).  This allows the repository structure and
		the commit messages to remain concerned with the source code, and not
		have it fill up with uninformative messages about every little thing
		you do with HgBugs.
	
	Is HgBugs ever going to work with other DVCS?
		HgBugs was built to be as compartmentalized from the Mercurial API
		calls as possible, and the hope is that yes, some day HgBugs will work
		with any (distributed) tracker.
		
	Can I use HgBugs in a corporate environment?
		HgBugs is released under GPL2+ (for now - if it is refactored to work
		with any DVCS and no longer uses Mercurial API calls, it will likely
		be released under an MIT license - which wouldn't change the answer
		to this question) so yes, you may.  However you may not distribute
		HgBugs or any derived works under any license that is incompatible
		with the GPL2+.  If you're unsure, there's lots of information
		on the details of this license online, and you are welcome to contact
		me with questions.
	
	I have an idea for a feature, what should I do?
		HgBugs is released as open source software, so experiment, make it
		yourself if you feel so inclined.  You're also welcome to email me
		with suggestions, questions or code changes.  Or even pull the
		repository, file a bug there, and serve it up somewhere for me
		to pull it back!  How's that for dogfooding?
		
I hope you find HgBugs useful!